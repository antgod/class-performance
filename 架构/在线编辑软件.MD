1.如何与后端交互

    - 接口端采用restful规范：返回内容可以是json数据（数据格式），文本数据，二进制数据，流数据
        注意点:提前定义好参数规则,比如
        某些特定的数据格式,需要传递固定的Content-Type.否则服务端返回的

    - 提供接口mock平台，可以自行模拟接口数据，上传文件（如图片），在后端接口没有准备好时候，可以自行模拟数据测试产品效果.

    - Node端合并多个接口请求，并行处理多个异步请求，采用Promise.all与CO/Generator或async合并接口请求

    - node端实现事务回滚\异常处理\打印请求日志\单点登录以及接口加密认证等自动化功能，防止其他人随意调用接口或者篡改包数据.
    并且能在接口报错时,通过日志快速定位异常问题。

    - 前端提供两套接口调用方案
        1.供给开发人员使用：类似于postman发送请求，可以在界面编写cookie,header，query string，requestbody等数据。
        2.供给非开发人员使用：
              1.输入实体（搜索下拉框），获得实体数据
              2.开发人员开发后，保存到服务器端。

2.在线用户体验

    - 提供页面风格模板，每个（或者多个）模板对应一个使用场景（可以按业务：营销/广告/交易/商品展示等划分模板或者按终端：PC/手机
    /平板划分模板）。提供一小段视频录像，用来介绍模板如何使用。

    - 所见即所得,每次拖拽后自动保存(配置信息需要手动保存),用户再次登陆还原上次保存的控件.提供给用户可编码API,以便处理各个组件异
    构情况(比如一个轮播banner,轮播速度,轮播是否停止等参数,要对外提供可配置的接口,如果可能的话,最好提供可编程接口.以便用户二次开
    发.样式文件要对外开发,因为样式经常会在不同产品需求下频繁改变,重写样式在所难免)

    - 前端样式使用css3/4与预编译技术（stylus/sass/precss/less等postcss技术）编写皮肤与常见公用组件(比如input标签,gap,表格,第三
    方登陆,支付).

    - 性能优化
        1.采用主动式（模拟用户环境发起请求）\被动式（注入脚本、代理服务器探针）双方案探测用户访问平均时长。
        2.传统的性能优化原则:减少http请求次数,使用内容分发系统,合并请求与压缩等.
        3.采用服务端同步渲染,加快首屏渲染时间.

    - 做好容错处理
        1.接口返回状态码,异常信息,调用时长给出提示
        2.前端给出友好的异常信息:
            如:没有获得组件配置数据,没有传入组件适当的props,在render函数修改了state,在后端渲染的声明周期中操作了dom元素等
        3.给出页面不合理的设计\操作提示:
            如:页面没有

    - 给出良好的在线编辑器
        1.使用runjs等在线编辑器,提供即使保存刷新功能.
        2.每编写一个未发布组件,采用服务器端推送(websocket)机制自动刷新项目脚手架(界面编辑器)界面,以便让使用组件者实时使用最新
        组件而不用重新刷新页面
        3.对于已发布的组件,每次上线(推送到npm发布版本)以后,才能实时刷新,避免使用者频繁刷新组件信息.

3.使用什么技术，需要注意哪些?

     采用react-babel-webpack(es6/7),redux/noflux,fetch,node,react-server(koa)等技术

         优点：
            1.自带模板与模块化\组件化，易做组件拆分
            2.react组件代码风格偏向统一,生命周期定义明确,状态机和外传参数易于理解
            3.内嵌小型资源文件,比如小型图标,很容易做base64处理
            4.我们只需要关心组件内部内容,而不必
            5.提供了良好的IDE(Atom,WebStorm)与调试工具(SourceMap)
            6.服务端同构渲染+虚拟节点和dom diff，渲染速度快

         缺点以及注意事项：
            1.学习成本比较大,state交互困难,数据驱动界面对习惯jq的人转型较难.
            2.不太适合dom操作,比如拖拽.我们需要在组件渲染完毕后,手动添加事件处理组件拖拽.
            3.react文件过大,首次下载可能花费较长时间,第二次由于有304缓存,速度会快很多.
            4.组件理论上不应该产生耦合性交互.所以可以通过发布订阅或者全局状态修改交互,这样可以避免组件交互时候报错.
            5.定义好组件规范,传入参数限制,以免使用者不知如何使用.

4.目录结构

    bin         //存放sh脚本,比如线上编译脚本,发布cdn脚本等

    client      //前端静态文件目录
        component        //组件
            view         //视图组件,如:如各种Input,日期,弹框,按钮,表格,表单,轮播,Loading,Gap等组件.
            public       //公共组件,如:登陆,权限,边栏,菜单,异常展示,支付,地址选择等组件
            business     //业务组件,各个业务方私有组件
        resource         //资源文件:如:图片,文档,视频等
        page             //界面入口文件,每个入口对应一个url
        vendor           //第三方
        modules          //其他模块
            fonts        //字体图标
            styles       //初始化样式

    config               //项目配置文件

    tasks                //编译工具(gulp/fis等)的任务

    server
        mock             //调用mock接口的文件
        controller       //action层,负责请求控制
        service          //服务层,负责调用接口/数据库,以及处理后端请求
    static               //前端资源文件编译后文件,以此目录下文件存放到cdn.

5.构建生成工具

    //项目初始化
    yeoman
    //项目打包\灰度部署
    gulp
    //项目编译
    webpack
