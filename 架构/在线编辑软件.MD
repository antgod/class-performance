##设计方案：

1. 页面是模板+多个组件拼装而成
1. 可以配置模板的基本信息：如页面名称、标题、分享信息
1. 组件由代码和配置数据（json）组合而成
1. 组件可以被多次开发,可以被到处使用
1. 组件可以被拖拽，可以缩放大小
1. 组件可以配置属性，可以重写样式，可配置接口参数
1. 支持浏览器调试、手机调试与下载调试
1. 一个页面可以被多个组件拼装后，发布页面到服务器（一键发布, 需保证服务器配置好了对应目录的访问权限）

##开发一个组件的流程
这个流程的角色主要对应是前端开发, 需要保证开发模式足够舒畅.

1. 新建组件模板，编写组件代码
1. 编写组件配置文件以及mock数据
1. 在线预览组件内容
1. 修改组件配置文件\mock数据，监听组件修改，页面刷新
1. 开发完成，上传服务器（重新编译, 覆盖上一个版本）

##如何与后端交互

1. 接口端采用restful规范：返回内容可以是json数据（数据格式），文本数据，二进制数据，流数据
    - 注意点:提前定义好参数规则,比如某些特定的数据格式,需要传递固定的Content-Type.

1. 提供接口mock平台，可以自行模拟接口数据，上传文件（如图片），在后端接口没有准备好时候，可以自行模拟数据测试产品效果

1. Node端合并多个接口请求，并行处理多个异步请求，采用Promise.all与CO/Generator或async合并接口请求

1. node端实现事务回滚\异常处理\打印请求日志\单点登录以及接口加密认证等自动化功能，防止其他人随意调用接口或者篡改包数据
    并且能在接口报错时,通过日志快速定位异常问题

1. 前端提供两套接口调用方案
    - 供给开发人员使用：类似于postman发送请求，可以在界面编写cookie,header，query string，requestbody等数据
    - 供给非开发人员使用：
        - 输入实体（搜索下拉框），获得实体数据
        - 开发人员开发后，保存到服务器端

##在线用户体验

1. 向导功能 
    - 页面风格模板，每个（或者多个）模板对应一个使用场景（可以按业务：营销/广告/交易/商品展示等划分模板或者按终端：PC/手机
        /平板划分模板）
    - 提供一小段视频录像，用来介绍模板如何使用

1. 所见即所得
    - 每次拖拽后自动保存(配置信息需要手动保存),用户再次登陆还原上次保存的控件
    - 提供给用户可编码API,以便处理各个组件异构情况(比如一个轮播banner,轮播速度,轮播是否停止等参数,要对外提供可配置的接口,如果可能的话,最好提供可编程接口.以便用户二次开发.样式文件要对外开发,因为样式经常会在不同产品需求下频繁改变,重写样式在所难免)

1. 前端样式
    
    使用css3与预编译技术（stylus/sass/precss/less等postcss技术）编写皮肤与常见公用组件(比如input标签,gap,表格,第三方登陆,支付),确保用户使用皮肤与组件风格统一

1. 性能优化
    - 采用主动式（模拟用户环境发起请求）\被动式（注入脚本、代理服务器探针）双方案探测用户访问平均时长
    - 传统的性能优化原则:减少http请求次数,使用内容分发系统,合并请求与压缩等
    - 采用服务端同步渲染,加快首屏渲染时间

1. 做好容错处理
    - 接口返回状态码,异常信息,调用时长给出提示
    - 前端给出友好的异常信息:
        
        如:没有获得组件配置数据,没有传入组件适当的props,在render函数修改了state,在后端渲染的声明周期中操作了dom元素等
    - 给出页面不合理的设计\操作提示

1. 给出良好的在线编辑器
    - 使用runjs等在线编辑器,提供即使保存刷新功能
    - 每编写一个未发布组件,采用服务器端推送(websocket)机制自动刷新项目脚手架(界面编辑器)界面,以便让使用组件者实时使用最新组件而不用重新刷新页面
    - 对于已发布的组件,每次上线(推送到npm发布版本)以后,才能实时刷新,避免使用者频繁刷新组件信息.

##使用什么技术，需要注意哪些?

使用react-babel-webpack(es6/7),noflux,fetch,node,react-server(koa) css3,sass,yeoman,gulp,html5等技术

- 优点：
    1. 自带模板与模块化\组件化，易做组件拆分
    1. react组件代码风格偏向统一,生命周期定义明确,状态机和外传参数易于理解
    1. 内嵌小型资源文件,比如小型图标,很容易做base64处理
    1. 我们只需要关心组件内部内容,而不必
    1. 提供了良好的IDE(Atom,WebStorm)与调试工具(SourceMap)
    1. 服务端同构渲染+虚拟节点和dom diff，渲染速度快

- 缺点以及注意事项：
    1. 学习成本比较大,state交互困难,数据驱动界面对习惯jq的人转型较难.
    1. 不太适合dom操作,比如拖拽.我们需要在组件渲染完毕后,手动添加事件处理组件拖拽.
    1. react文件过大,首次下载可能花费较长时间,第二次由于有304缓存,速度会快很多.
    1. 组件理论上不应该产生耦合性交互.所以可以通过发布订阅或者全局状态修改交互,这样可以避免组件交互时候报错
    1. 定义好组件规范,传入参数限制,以免使用者不知如何使用

##目录结构

    bin         //存放sh脚本,比如线上编译脚本,发布cdn脚本等

    client      //前端静态文件目录
        component        //组件
            view         //视图组件,如:如各种Input,日期,弹框,按钮,表格,表单,轮播,Loading,Gap等组件.
            public       //公共组件,如:登陆,权限,边栏,菜单,异常展示,支付,地址选择等组件
            business     //业务组件,各个业务方私有组件
        resource         //资源文件:如:图片,文档,视频等
        page             //界面入口文件,每个入口对应一个url
        vendor           //第三方
        template         //模板文件
        modules          //其他模块
            fonts        //字体图标
            styles       //初始化样式

    config               //项目配置文件

    tasks                //编译工具(gulp/fis等)的任务

    server
        mock             //调用mock接口的文件
        controller       //action层,负责请求控制
        service          //服务层,负责调用接口/数据库,以及处理后端请求
    static               //前端资源文件编译后文件,以此目录下文件存放到cdn.

##构建生成工具

1. 项目初始化：生成项目，模板，组件模板等目录结构

    yeoman
    
1. 项目打包：文件合并，打包
    
    gulp
    
1. 项目编译：编译es,图片压缩
    
    webpack
    
1. 项目发布：灰度部署，发布到服务器
   
    jenkins+shell
    
##注意点与难点
1.     node启动一个socket，来监组件的页面文件变化,变化后重新向服务器拉取最新编译好的组件, 进行更新.
1.     为了不影响页面的展示，预览应该内嵌iframe窗体预览，使用postMessage像子窗体传递数据。
1.     前端拖拽以及组件缩放，拖拽与缩放算是这个项目的难点，涉及到碰撞检测以及缩放后布局打乱。
1.     组件永远使用最新版本，为了避免手动编写项目版本，每次生成项目，自用生成版本号以及Tag信息。
1.     监控与统计，采用后端探针+前端注入脚本方式统计性能以及报错信息
1.     移动端调试一直以来是个让人头疼的问题，pc端可以很方便的使用谷歌开发者工具，而移动端自动迁入debug,logger,wenire等调试脚本。如果在浏览器（非app）环境下，可以使用谷歌浏览器或safiri直接调试。
1.     关于复杂组件的代码拆分，采用继承以及decorator装饰器分离主文件逻辑代码，主Class只保存jsx代码，继承类Action编写所有事件代码，decorator编写生命周期、get/set方法以及私有函数等。  
    
